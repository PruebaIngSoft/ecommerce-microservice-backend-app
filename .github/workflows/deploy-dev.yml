# Pipeline de Deploy a DEV
#
# PROPÓSITO: Desplegar a ambiente de desarrollo (namespace: dev)
# SE EJECUTA: Solo cuando hay push a la rama 'develop'
#
# FLUJO:
# 1. Build de todas las imágenes Docker
# 2. Push a Azure Container Registry con tag :dev
# 3. Deploy a AKS en namespace 'dev'
# 4. Ejecutar tests E2E
#
# NOTA: Este ambiente es para integración y pruebas antes de producción
name: Deploy to DEV

on:
  push:
    branches: [dev]
    paths-ignore:
      - '**.md'
      - 'docs/**'

env:
  JAVA_VERSION: '11'
  REGISTRY_NAME: ${{ secrets.ACR_LOGIN_SERVER }}
  RESOURCE_GROUP: ${{ secrets.AKS_RESOURCE_GROUP }}
  CLUSTER_NAME: ${{ secrets.AKS_CLUSTER_NAME }}
  NAMESPACE: dev

jobs:
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'maven'

      - name: Build with Maven
        run: mvn clean package -DskipTests -B

      - name: Login to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ secrets.ACR_LOGIN_SERVER }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Build and push Docker images
        run: |
          TAG="${{ github.sha }}"
          TAG_LATEST="dev"
          
          SERVICES="service-discovery cloud-config api-gateway product-service user-service order-service payment-service shipping-service favourite-service proxy-client"
          
          for service in $SERVICES; do
            echo "========================================="
            echo "Building and pushing: $service"
            echo "========================================="
            
            docker build -f ./$service/Dockerfile -t ${{ env.REGISTRY_NAME }}/$service:$TAG .
            docker tag ${{ env.REGISTRY_NAME }}/$service:$TAG ${{ env.REGISTRY_NAME }}/$service:$TAG_LATEST
            
            docker push ${{ env.REGISTRY_NAME }}/$service:$TAG
            docker push ${{ env.REGISTRY_NAME }}/$service:$TAG_LATEST
            
            echo "✓ $service pushed with tags: $TAG, $TAG_LATEST"
          done

  deploy:
    name: Deploy to AKS (dev namespace)
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: development
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.CLUSTER_NAME }} \
            --overwrite-existing

      - name: Apply RBAC Security Configuration
        run: |
          echo "Applying RBAC policies..."
          kubectl apply -f k8s/security-rbac.yaml

      - name: Verify RBAC Permissions (Evidence)
        run: |
          echo "--- PRUEBA DE SEGURIDAD RBAC ---"
          echo "1. ¿El auditor puede VER pods? (Esperado: yes)"
          kubectl auth can-i list pods --as=system:serviceaccount:default:dev-auditor
          
          echo "2. ¿El auditor puede BORRAR pods? (Esperado: no)"
          # Agregamos '|| true' para que el 'exit code 1' (no) no rompa el pipeline
          kubectl auth can-i delete pods --as=system:serviceaccount:default:dev-auditor || true 
          echo "--------------------------------"

      - name: Setup Ingress Controller & TLS
        run: |
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/cloud/deploy.yaml
          
          sleep 60 
          
          openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout tls.key -out tls.crt \
            -subj "/CN=ecommerce.local/O=Ingesoft/C=CO"
          
          kubectl create secret tls ecommerce-tls-secret \
            --key tls.key --cert tls.crt \
            -n ${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create namespace if not exists
        run: |
          kubectl apply -f k8s/namespaces.yaml
          kubectl get namespace ${{ env.NAMESPACE }}

      - name: Clean up old deployments (dev environment only)
        run: |
          echo "Cleaning up old deployments in dev namespace to free resources..."
          kubectl delete deployment --all -n ${{ env.NAMESPACE }} || true
          kubectl delete svc --all -n ${{ env.NAMESPACE }} || true
          echo "Cleanup completed. Ready for fresh deployment."

      - name: Install envsubst
        run: |
          sudo apt-get update
          sudo apt-get install -y gettext-base

      - name: Deploy services to DEV namespace
        run: |
          # Variables para sustituir en manifiestos
          export ACR_LOGIN_SERVER="${{ env.REGISTRY_NAME }}"
          export TAG="${{ github.sha }}"
          
          # Deploy en orden de dependencias
          echo "Deploying infrastructure services..."
          kubectl apply -f k8s/zipkin.yaml -n ${{ env.NAMESPACE }}
          envsubst < k8s/service-discovery.yaml | kubectl apply -n ${{ env.NAMESPACE }} -f -
          
          echo "Waiting for service-discovery..."
          kubectl rollout status deployment/service-discovery -n ${{ env.NAMESPACE }} --timeout=120s || true
          
          echo "Deploying cloud-config..."
          envsubst < k8s/cloud-config.yaml | kubectl apply -n ${{ env.NAMESPACE }} -f -
          kubectl rollout status deployment/cloud-config -n ${{ env.NAMESPACE }} --timeout=120s || true
          
          echo "Deploying application services..."
          envsubst < k8s/product-service.yaml | kubectl apply -n ${{ env.NAMESPACE }} -f -
          envsubst < k8s/user-service.yaml | kubectl apply -n ${{ env.NAMESPACE }} -f -
          envsubst < k8s/order-service.yaml | kubectl apply -n ${{ env.NAMESPACE }} -f -
          envsubst < k8s/payment-service.yaml | kubectl apply -n ${{ env.NAMESPACE }} -f -
          envsubst < k8s/shipping-service.yaml | kubectl apply -n ${{ env.NAMESPACE }} -f -
          envsubst < k8s/favourite-service.yaml | kubectl apply -n ${{ env.NAMESPACE }} -f -
          
          echo "Deploying gateway and proxy..."
          envsubst < k8s/api-gateway.yaml | kubectl apply -n ${{ env.NAMESPACE }} -f -
          envsubst < k8s/proxy-client.yaml | kubectl apply -n ${{ env.NAMESPACE }} -f -

          echo "Deploying Ingress (HTTPS) rules..."
          export NAMESPACE="${{ env.NAMESPACE }}"
          envsubst < k8s/ingress.yaml | kubectl apply -f -

      - name: Wait for deployments
        run: |
          echo "Waiting for all deployments to be ready..."
          DEPLOYMENTS="product-service user-service order-service payment-service shipping-service favourite-service api-gateway"
          for deploy in $DEPLOYMENTS; do
            echo "Checking $deploy..."
            kubectl rollout status deployment/$deploy -n ${{ env.NAMESPACE }} --timeout=180s || true
          done

      - name: Show deployment status
        run: |
          echo "========================================="
          echo "Deployment Status in ${{ env.NAMESPACE }}"
          echo "========================================="
          kubectl get pods -n ${{ env.NAMESPACE }}
          echo ""
          kubectl get services -n ${{ env.NAMESPACE }}

  e2e-tests:
    name: Run E2E Tests
    runs-on: ubuntu-latest
    needs: deploy
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'maven'

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.CLUSTER_NAME }}

      - name: Get API Gateway URL
        id: get-url
        run: |
          # Esperar a que el LoadBalancer tenga IP
          for i in {1..30}; do
            IP=$(kubectl get svc api-gateway -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            if [ -n "$IP" ]; then
              echo "API_URL=http://$IP:8080" >> $GITHUB_OUTPUT
              echo "Found API Gateway at: http://$IP:8080"
              break
            fi
            echo "Waiting for LoadBalancer IP... ($i/30)"
            sleep 10
          done

      - name: Run E2E Tests
        run: |
          cd api-gateway
          mvn test -Dtest="**/e2e/**" -DAPI_URL=${{ steps.get-url.outputs.API_URL }} -B
        continue-on-error: true

      - name: Upload E2E test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-results-dev
          path: '**/target/surefire-reports/*.xml'
          retention-days: 7

  security-scan-zap:
    name: OWASP ZAP Security Scan (DAST)
    runs-on: ubuntu-latest
    needs: deploy
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.CLUSTER_NAME }}

      - name: Get API Gateway URL
        id: get-url
        run: |
          for i in {1..30}; do
            IP=$(kubectl get svc api-gateway -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            if [ -n "$IP" ]; then
              echo "API_URL=http://$IP:8080" >> $GITHUB_OUTPUT
              echo "Found API Gateway at: http://$IP:8080"
              break
            fi
            echo "Waiting for LoadBalancer IP... ($i/30)"
            sleep 10
          done

      - name: Run ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.14.0
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          docker_name: 'ghcr.io/zaproxy/zaproxy:stable'
          target: '${{ steps.get-url.outputs.API_URL }}/actuator/health'
          fail_action: false
          cmd_options: '-a'

      - name: Upload ZAP HTML Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: zap-security-report
          path: report_html.html
          retention-days: 7

      - name: Upload ZAP Markdown Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: zap-security-report-md
          path: report_md.md
          retention-days: 7
